# index
> 데이터베이스의 인덱스는 중요한 개념중 하나, 데이터의 검색 성능을 잘 상요하면 정말 높은 성능을 향상 시킬수 있다. 데이터의 빠른 접근을 할수 있게 만들어주는 자료구조

# DBMS index
> b-tree 기반의 동작을 할수 있다.
> b-tree 기반의 인덱스를 생성한다.
> 데이터가 한글이면, 초성, 중성, 종성 순서로 구분 사전식
> 정령된 인덱스는 실제 테이블의 데이터의 포인터의 값을 하나씩 갖는다.
> id를 찾는다고 가정하면
> `바이너리 서치`를 한다
> 쉽게 말해서 전체 데이터의 가운데 값을 조회하고 가운데 값이 찾는 값보다 큰지 비교하고 작은지 비교하고 다음 기준에서 또 반복 찾으면 찾은 기준에 데이터 위 아래를 맞는 범위까지 조회하고 안맞으면 끝

> 두개의 값을 찾는다 가정할때
> 인덴스는 하나만 설정이 되어 있다고 가정하고
> 위와 동일하게 바이너리 서치를 하고 두번째 값을 포인터로 참조해서 모두 확인한다.
> 맞는지 맞지 않는지 조건을 모두 찾을때까지 확인하면서 포인터 접근을 하기 때문에
> 두번째 컬럼은 fullscan을 하게 된다.

> 그래서 둘다 멀티 컬럼 인덱스로 묶어서 관리하면
> 위와 동일하게 바이너리 서치를 하는데 두 조건이 일치할때만 포인터접근을 한다. 좀더 효율적

> 멀티 컬럼 인덱스 묶은 순서에서 왼쪽의 컬럼을 순서대로 정렬하고 그 정렬한 순서의 기준으로 매핑되는 컬럼의 데이터를 오른쪽 컬럼의 데이터로 정렬한다.

> 인덱스가 조회에는 좋기는한데 막쓰면 위험하다 안쓴것만 못해
> 추가, 수정, 삭제가 오래 걸린다. 왜? 인덱스의 데이터로 생성이 되기 때문에(데이터의 저장 공간도 늘어난다.)
> 데이터베이스 오버헤드 : 너무 많은 인덱스가 있으면 DBMS 성능이 떨어진다.
> 꼭 필요한곳인지 확인 조회가 번번히 일어나고 데이터가 많은 경우

> 인덱스로 지정한 데이터가 전체 테이블의 데이터중에 상당수를 차지하는 경우에는 fullscan을 하는게 더 빠르다.

`옵티마이즈` : DMBS가 최적의 쿼리를 사용하게 만들어주는것

### index 구조
```sql
-- full scan
SELECT * FROM student2;
SELECT * FROM student2 WHERE name="soon";

CREATE TABLE student2(
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(50),
    email VARCHAR(50),
    age INT,
    class VARCHAR(10)
);
```

## 테이블의 값을 csv를 가져와서 추가해보자
> mysql 로컬 파잉을 읽을수 있는 상태인지 속성을 확인해봐야 한다.
```sql
SHOW GLOBAL VARIABLES LIKE "local_infile";

SET GLOBAL local_infile=ON;
```