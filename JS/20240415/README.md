# 재귀 함수
# 배열과 객체
# 실행 컨텍스트
# 함수의 tip


## 재귀 함수
> 재귀 함수는 함수의 내용에서 다시 자신을 호출해서 반복 작업을 하는 방식.
> for문으로도 반복문을 구현 가능한 로직들은 재귀 함수로 작성이 가능하다.
> 재귀 함수를 사용하는 이유는 반복하는 내용의 기능을 여러개로 나누고 직관적으로 관리할때
> 사용하는 프로그래밍 패던중하나.

> 재귀를 작성할때 더이상 나워야할 필요가 없을때 종료됨
> 문제를 나눠서 기능을 작성하는 경우 이 두가지 패턴을 찾아서 활용해야한다.

# 사용 예

## 반복문을 사용한 예
```js
let count = 0;
for (let i = 1; i <= 100; i++) {
    count += i;
}
```

## 반복문을 수학적 공식을 가지고 반복문을 줄이는 예
```js
let n = 100;
console.log((n / 2) * (n + 1));
// 하누이의 탑
```

## 재귀함수로 사용한 예
```js
function sum(n, result) {
    if (n === 101) {
        console.log(result);
        return n;
    }
    sum(n + 1, result + n);
}

```

## 재귀함수의 목적
> 장점으로 반복문을 많이 사용하는 경우보다 코드가 간결하고 직관적
> 하지만 단저믕로 스택에 함수 실행이 쌓여서 메모리 공간을 많이 차지하고 속도 성능이 저하..

## 피보나치 수열을 만든다.
> 피보나치 수열은 토끼가 처음에 한쌍이 있고
> 한달이 지나면 한쌍의 토끼가 성장
> 그 이후 한달이 지나면 성장한 토끼가 새끼토끼 한쌍을 낳는다.
> 그 이후 한달이 지나면 성장한 토끼는 또 번식을 하고 새끼토끼는 성장해서 성체 토끼가 된다.
> 이런식으로 계속 증가하는 수열
> 규칙은 토끼는 죽지않고 한달이 지나야 성체가 된다.

```js
funtion fibo(n) {
    if (n == 1 || n == 2) return 1;
    return fibo(n - 1) + fibo(n - 2);
}
```

## 메모이제이션
> `상태`의 데이터를 만들때 연산을 한 내용을 반복하지 않게 하는것이 목적
> `상태`의 데이터를 저장하면서 반복되는 연산을 줄이는 기법

## 객체 문법
```js
let memo = {
    name : "이순현",
    color : "black"
};
// name 객체의 키 "이순현"이라는 값
"name" in memo === true;
"name2" in memo === false;
memo["name"] === "이순현";
```

```js
// memo 빈 객체 생성
// 상태 데이터를 객체에다 담아두려고
let memo = {};

// in 예약어
// 객체안에 키가 있는지 확인
// 반환값은 true false

function fibo2(n) {
    let result; // 연산을 하고 반환한 값

    // 한번 상태를 만든 연산인지.
    if (n in memo) {
        // 연산을 했었어
        result = memo[n];
        // 객체를 하고 넘어오면 더 이해가 될거니까.
    } else {
        // 연산을 안했었어
        if (n == 1 || n == 2) {
            result = 1;
        } else {
            result = fibo(n - 1) + fibo(n - 2);
        }

        // 다음번에 연산을 하지 않게 하기 위해서 상태값을 저장
        memo[n] = result;
    }

    return result;
}
```
## 2 + 2
## 실습 재귀함수로 짝수를 더하는 함수를 재귀적으로 돌리자 더하는 횟수는 인자값으로 전달 받아서.
